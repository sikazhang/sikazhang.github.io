<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>WHUZXQ&#39;S BLOG</title>
    <link>http://myhexo.whuzxq.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>前端伊甸园</description>
    <pubDate>Tue, 31 Jul 2018 17:02:48 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>不聊webpack配置，来说说它的原理</title>
      <link>http://myhexo.whuzxq.com/2018/06/15/webpack/</link>
      <guid>http://myhexo.whuzxq.com/2018/06/15/webpack/</guid>
      <pubDate>Fri, 15 Jun 2018 06:34:11 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近在前端论坛闲逛，看到了一些讲parcel、webpack的文章，就突然很好奇，每天都在用的打包工具，他们打包的原理究竟是什么。只有知道了这一点，才可以在众多的打包工具里，找到最适合的那个它。在了解打包原理之前，先花一些篇章说明了一下为什么要使用打包工具。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>最近在前端论坛闲逛，看到了一些讲parcel、webpack的文章，就突然很好奇，每天都在用的打包工具，他们打包的原理究竟是什么。只有知道了这一点，才可以在众多的打包工具里，找到最适合的那个它。在了解打包原理之前，先花一些篇章说明了一下为什么要使用打包工具。<br><a id="more"></a></p><h2 id="0-模块系统"><a href="#0-模块系统" class="headerlink" title="0.模块系统"></a>0.模块系统</h2><p>  前端产品的交付是基于浏览器，这些资源是通过增量加载的方式运行到浏览器端，如何在开发环境组织好这些碎片化的代码和资源，并且保证他们在浏览器端快速、优雅的加载和更新，就需要一个模块化系统。这个理想中的模块化系统是前端工程师多年来一直探索的难题。</p><p>  <strong>模块系统主要解决模块的定义、依赖和导出。</strong> 原始的<code>&lt;script&gt;</code>标签加载方式有一些常见的弊端：例如全局作用域下容易造成变量冲突；文件只能按照<code>&lt;script&gt;</code>的书写顺序进行加载；开发人员必须主观解决模块和代码库的依赖关系等。</p><p><strong>因此衍生出很多模块化方案：</strong></p><p><strong>1.CommonJs</strong>：优点：服务器端模块便于重用。缺点：同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的。</p><p><strong>2.AMD</strong>：依赖前置。优点：适合在浏览器环境异步加载；缺点：阅读和书写比较困难。</p><p><strong>3.CMD</strong>：依赖就近，延迟执行。优点：很容易在node中运行；缺点：依赖spm打包，模块的加载逻辑偏重。</p><p><strong>4.ES6模块：</strong>:尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。优点：容易进行静态分析；缺点：原生浏览器未实现该标准。</p><p>说到模块的加载和传输，若是每个文件都单独请求，会导致请求次数过多，导致启动速度过慢。若是全部打包在一块只请求一次，会导致流量浪费，初始化过程慢。<strong>因此最佳方案是分块传输，按需进行懒加载，在实际用到某些模块的时候再增量更新</strong>。要实现模块的按需加载，就需要一个对整个代码库中的模块进行<strong>静态分析、编译打包</strong>的过程。Webpack 就是在这样的需求中应运而生。</p><p>注：要注意一个概念，一切皆模块。样式、图片、字体、HTML 模板等等众多的资源，都可以视作模块。</p><h2 id="1-模块打包器：webpack"><a href="#1-模块打包器：webpack" class="headerlink" title="1.模块打包器：webpack"></a>1.模块打包器：webpack</h2><p>Webpack 是一个模块打包器。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。<br>那么问题来了，webpack真的能做到上述提到的静态分析、编译打包么？我们首先来看一下webpack能做什么：</p><p> <strong>1.代码拆分</strong><br> Webpack 有两种组织模块依赖的方式，同步和异步。异步依赖作为分割点，形成一个新的块。在优化了依赖树后，每一个异步区块都作为一个文件被打包。</p><p> <strong>2.Loader</strong><br> Webpack 本身只能处理原生的 JavaScript 模块，但是 loader 转换器可以将各种类型的资源转换成 JavaScript 模块。这样，任何资源都可以成为 Webpack 可以处理的模块。</p><p> <strong>3.智能解析</strong><br>Webpack 有一个智能解析器，几乎可以处理任何第三方库，无论它们的模块形式是 CommonJS、 AMD 还是普通的 JS 文件。</p><p><strong>4.插件系统</strong><br>Webpack 还有一个功能丰富的插件系统。大多数内容功能都是基于这个插件系统运行的，还可以开发和使用开源的 Webpack 插件，来满足各式各样的需求。</p><p><strong>5.快速运行</strong><br>Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译。</p><p>以上是webpack五个主要特点，但是看完还是觉得有些雾里看山，webpack到底是如何把一些分散的小模块，整合成大模块？又是如何处理好各模块的依赖关系？下面就以parcel核心开发者@ronami的开源项目minipack为例，说明以上问题。</p><h2 id="2-打包工具核心原理——以minipack为例"><a href="#2-打包工具核心原理——以minipack为例" class="headerlink" title="2.打包工具核心原理——以minipack为例"></a>2.打包工具核心原理——以minipack为例</h2><p>打包工具就是负责把一些分散的小模块，按照一定的规则整合成一个大模块的工具。与此同时，打包工具也会处理好模块之间的依赖关系，将项目运行在平台上。minipack项目最想说明的问题，也是打包工具最核心的部分，就是如何处理好<strong>模块间的依赖关系</strong>。</p><p>首先，打包工具会从一个入口文件开始，分析里面的依赖，并进一步地分析依赖中的依赖。<br>我们新建三个文件，并建立依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* name.js */</span><br><span class="line">export const name = &apos;World&apos;</span><br><span class="line"></span><br><span class="line">/* message.js */</span><br><span class="line">import &#123; name &#125; from &apos;./name.js&apos;</span><br><span class="line">export default `Hello $&#123;name&#125;!`</span><br><span class="line"></span><br><span class="line">/* entry.js */</span><br><span class="line">import message from &apos;./message.js&apos;</span><br><span class="line">console.log(message)</span><br></pre></td></tr></table></figure><p>首先引入必要的工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* minipack.js */</span><br><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">const babylon = require(&apos;babylon&apos;)</span><br><span class="line">const traverse = require(&apos;babel-traverse&apos;).default</span><br><span class="line">const &#123; transformFromAst &#125; = require(&apos;babel-core&apos;)</span><br></pre></td></tr></table></figure><p>接着我们将创建一个函数，参数是文件的路径，作用是读取文件内容并提取它的依赖关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">function createAsset(filename) &#123;</span><br><span class="line">  // 以字符串形式读取文件的内容. </span><br><span class="line">  const content = fs.readFileSync(filename, &apos;utf-8&apos;);</span><br><span class="line">// 现在我们试图找出这个文件依赖于哪个文件。虽然我们可以通过查看其内容来获取import字符串. 然而,这是一个非常笨重的方法，我们将使用JavaScript解析器来代替。</span><br><span class="line">  </span><br><span class="line">// JavaScript解析器是可以读取和理解JavaScript代码的工具，它们生成一个更抽象的模型,称为`ast (抽象语法树)(https://astexplorer.net)`。</span><br><span class="line">  const ast = babylon.parse(content, &#123;</span><br><span class="line">    sourceType: &apos;module&apos;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">// 定义数组，这个数组将保存这个模块依赖的模块的相对路径.</span><br><span class="line">  const dependencies = [];</span><br><span class="line"></span><br><span class="line">//  我们遍历`ast`来试着理解这个模块依赖哪些模块，要做到这一点,我们需要检查`ast`中的每个 `import` 声明。</span><br><span class="line">// `Ecmascript`模块相当简单,因为它们是静态的. 这意味着你不能`import`一个变量,或者有条件地`import`另一个模块。每次我们看到`import`声明时,我们都可以将其数值视为`依赖性`。</span><br><span class="line">  traverse(ast, &#123;</span><br><span class="line">    ImportDeclaration: (&#123;node&#125;) =&gt; </span><br><span class="line">        // 我们将依赖关系存入数组</span><br><span class="line">        dependencies.push(node.source.value);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">//   我们还通过递增简单计数器为此模块分配唯一标识符. </span><br><span class="line">  const id = ID++;</span><br><span class="line"></span><br><span class="line">//  我们使用`Ecmascript`模块和其他JavaScript,可能不支持所有浏览器。</span><br><span class="line">//  为了确保我们的程序在所有浏览器中运行,</span><br><span class="line">//  我们将使用[babel](https://babeljs.io)来进行转换。</span><br><span class="line">//  我们可以用`babel-preset-env``将我们的代码转换为浏览器可以运行的东西. </span><br><span class="line">  const &#123;code&#125; = transformFromAst(ast, null, &#123;</span><br><span class="line">    presets: [&apos;env&apos;],</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 返回有关此模块的所有信息.</span><br><span class="line">  return &#123;</span><br><span class="line">    id,</span><br><span class="line">    filename,</span><br><span class="line">    dependencies,</span><br><span class="line">    code,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以提取单个模块的依赖关系，那么，我们将提取它的每一个依赖关系的依赖关系，并循环下去，直到我们了解应用程序中的每个模块以及他们是如何相互依赖的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function createGraph(entry) &#123;</span><br><span class="line">  // 首先解析整个文件.</span><br><span class="line">  const mainAsset = createAsset(entry);</span><br><span class="line"></span><br><span class="line">//   我们将使用queue来解析每个asset的依赖关系. </span><br><span class="line">//   我们正在定义一个只有entry asset的数组.</span><br><span class="line">  const queue = [mainAsset];</span><br><span class="line"></span><br><span class="line">// 我们使用一个`for ... of`循环遍历 队列. </span><br><span class="line">// 最初 这个队列 只有一个asset,但是当我们迭代它时,我们会将额外的assert推入到queue中. </span><br><span class="line">// 这个循环将在queue为空时终止. </span><br><span class="line">  for (const asset of queue) &#123;</span><br><span class="line">    // 我们的每一个asset都有它所依赖模块的相对路径列表. </span><br><span class="line">    // 我们将重复它们,用我们的`createAsset() `函数解析它们,并跟踪此模块在此对象中的依赖关系.</span><br><span class="line">    asset.mapping = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // 这是这个模块所在的目录. </span><br><span class="line">    const dirname = path.dirname(asset.filename);</span><br><span class="line"></span><br><span class="line">    // 我们遍历其相关路径的列表</span><br><span class="line">    asset.dependencies.forEach(relativePath =&gt; &#123;</span><br><span class="line">    // 我们可以通过将相对路径与父资源目录的路径连接,将相对路径转变为绝对路径.</span><br><span class="line">      const absolutePath = path.join(dirname, relativePath);</span><br><span class="line"></span><br><span class="line">    // 解析asset,读取其内容并提取其依赖关系.</span><br><span class="line">      const child = createAsset(absolutePath);</span><br><span class="line"></span><br><span class="line">    //   了解`asset`依赖取决于`child`这一点对我们来说很重要. </span><br><span class="line">    //   通过给`asset.mapping`对象增加一个新的属性(值为child.id)来表达这种一一对应的关系.</span><br><span class="line">      asset.mapping[relativePath] = child.id;</span><br><span class="line"></span><br><span class="line">      // 最后,我们将`child`这个资产推入队列,这样它的依赖关系也将被迭代和解析.</span><br><span class="line">      queue.push(child);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们定义一个函数，传入上一步的graph，返回一个可以在浏览器上运行的包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function bundle(graph) &#123;</span><br><span class="line">  let modules = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">// 在我们到达该函数的主体之前,我们将构建一个作为该函数的参数的对象. </span><br><span class="line">// 请注意,我们构建的这个字符串被两个花括号 (&#123;&#125;) 包裹,因此对于每个模块,</span><br><span class="line">// 我们添加一个这种格式的字符串: `key: value,`.</span><br><span class="line">  graph.forEach(mod =&gt; &#123;</span><br><span class="line">     //  图表中的每个模块在这个对象中都有一个entry. 我们用模块的id`作为`key`，用数组作为`value`</span><br><span class="line">    // 第一个参数是用函数包装的每个模块的代码. 这是因为模块应该被限定范围: 在一个模块中定义变量不会影响其他模块或全局范围. </span><br><span class="line">    </span><br><span class="line">    // 对于第二个参数,我们用`stringify`解析模块及其依赖之间的关系(也就是上文的asset.mapping). 解析后的对象看起来像这样: `&#123;&apos;./relative/path&apos;: 1&#125;`. </span><br><span class="line">    </span><br><span class="line">    // 这是因为我们模块的被转换后会通过相对路径来调用`require()`. 当调用这个函数时,我们应该能够知道依赖图中的哪个模块对应于该模块的相对路径. </span><br><span class="line">    modules += `$&#123;mod.id&#125;: [</span><br><span class="line">      function (require, module, exports) &#123; $&#123;mod.code&#125; &#125;,</span><br><span class="line">      $&#123;JSON.stringify(mod.mapping)&#125;,</span><br><span class="line">    ],`;</span><br><span class="line">    / 最后,使用`commonjs`,当模块需要被导出时,它可以通过改变exports对象来暴露模块的值. </span><br><span class="line">   // require函数最后会返回exports对象.</span><br><span class="line">    const result = `</span><br><span class="line">    (function(modules) &#123;</span><br><span class="line">      function require(id) &#123; </span><br><span class="line">        const [fn, mapping] = modules[id];</span><br><span class="line">        function localRequire(name) &#123; </span><br><span class="line">          return require(mapping[name]); </span><br><span class="line">        &#125;</span><br><span class="line">        const module = &#123; exports : &#123;&#125; &#125;;</span><br><span class="line">        fn(localRequire, module, module.exports); </span><br><span class="line">        return module.exports;</span><br><span class="line">      &#125;</span><br><span class="line">      require(0);</span><br><span class="line">    &#125;)(&#123;$&#123;modules&#125;&#125;)</span><br><span class="line">    `;</span><br><span class="line">  return result;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>运行！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const graph = createGraph(&apos;./example/entry.js&apos;);</span><br><span class="line">const result = bundle(graph);</span><br><span class="line">//得到结果，开心！</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p>更多信息可访问项目<a href="https://github.com/chinanf-boy/minipack-explain/blob/master/src/minipack.js" target="_blank" rel="noopener">github地址</a></p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>webpack解决了包与包之间潜在的循环依赖难题，同时，按需合并静态文件，以避免浏览器在网络取数阶段的并发瓶颈。除了打包，还可以进一步实现压缩（减少网络传输）和编译（ES6、JSX等语法向下兼容）的功能。</p><p>基于对webpack.config.js文件的配置，执行打包时的工作原理，可总结为：把页面逻辑当作一个整体，通过一个给定的入口文件，webpack从这个文件开始，找到所有的依赖文件，进行打包、编译、压缩，最后输出一个浏览器可识别的JS文件。</p><p>一个模块打包工具，第一步会从入口文件开始，对其进行依赖分析，第二步对其所有依赖再次递归进行依赖分析，第三步构建出模块的依赖图集，最后一步根据依赖图集使用CommonJS规范构建出最终的代码。</p><h2 id="4-参考网址"><a href="#4-参考网址" class="headerlink" title="4.参考网址"></a>4.参考网址</h2><p><a href="https://mp.weixin.qq.com/s/w-oXmHNSyu0Y_IlfmDwJKQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/w-oXmHNSyu0Y_IlfmDwJKQ</a></p><p><a href="https://github.com/chinanf-boy/minipack-explain/blob/master/src/minipack.js" target="_blank" rel="noopener">https://github.com/chinanf-boy/minipack-explain/blob/master/src/minipack.js</a></p><p><a href="https://zhaoda.net/webpack-handbook/configuration.html" target="_blank" rel="noopener">https://zhaoda.net/webpack-handbook/configuration.html</a></p>]]></content:encoded>
      
      <comments>http://myhexo.whuzxq.com/2018/06/15/webpack/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【译】想写出优雅的代码？试试这些ES6小tips</title>
      <link>http://myhexo.whuzxq.com/2018/05/23/es6/</link>
      <guid>http://myhexo.whuzxq.com/2018/05/23/es6/</guid>
      <pubDate>Wed, 23 May 2018 05:23:11 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近又重温了ES6的文档，发现除了箭头函数，解构赋值，扩展运算符这样常用的语法外，还有很多很给力的方法，不仅使代码更简洁，还可以提高代码的健壮性，更令我意外的是，浏览器兼容大部分的方法，无需babel也可完美运行。所以觉得很有必要整理一下，在项目中，抛弃陈旧的老古董写法，升级为ES6规范代码。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>最近又重温了ES6的文档，发现除了箭头函数，解构赋值，扩展运算符这样常用的语法外，还有很多很给力的方法，不仅使代码更简洁，还可以提高代码的健壮性，更令我意外的是，浏览器兼容大部分的方法，无需babel也可完美运行。所以觉得很有必要整理一下，在项目中，抛弃陈旧的老古董写法，升级为ES6规范代码。<br> <a id="more"></a></p><h1 id="一-数组升级"><a href="#一-数组升级" class="headerlink" title="一.数组升级"></a>一.数组升级</h1><h2 id="1-扩展运算符之复制数组"><a href="#1-扩展运算符之复制数组" class="headerlink" title="1.扩展运算符之复制数组"></a>1.扩展运算符之复制数组</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//es5做法</span></span><br><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> a2 = a1.concat()</span><br><span class="line"></span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line">a1 <span class="comment">//[1,2] 修改a2不会对a1有影响</span></span><br></pre></td></tr></table></figure><p>扩展运算符提供了复制数组的简便写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//es6做法</span></span><br><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> a2 = [...a1]</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="keyword">const</span> [...a2] = a1</span><br><span class="line"></span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line">a1 <span class="comment">//[1,2] 修改a2不会对a1有影响</span></span><br></pre></td></tr></table></figure></p><p>注：上述复制的过程是深拷贝，但是要注意的一点是，concat和扩展运算符用做<strong>合并数组</strong>时，都是浅拷贝。</p><h2 id="2-数组实例的find-和findIndex"><a href="#2-数组实例的find-和findIndex" class="headerlink" title="2.数组实例的find()和findIndex()"></a>2.数组实例的find()和findIndex()</h2><p>find方法，用于找出第一个符合条件的数组成员，它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后<strong>返回该成员</strong>。如果没有符合条件的成员，则返回undefined。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//es5做法</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i]&gt;<span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">//10</span></span><br><span class="line"><span class="comment">//es6做法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>].find(<span class="function"><span class="keyword">function</span>(<span class="params">value,index,arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value &gt; <span class="number">5</span></span><br><span class="line">&#125;) <span class="comment">//10</span></span><br></pre></td></tr></table></figure><p>另外，这两个方法都可以发现NaN,弥补了indexOf方法的不足。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf[<span class="literal">NaN</span>] <span class="comment">//-1</span></span><br><span class="line"></span><br><span class="line">[<span class="literal">NaN</span>].findIndex(<span class="function"><span class="params">y</span> =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>,y)) <span class="comment">//0</span></span><br></pre></td></tr></table></figure></p><h2 id="3-数组实例的includes"><a href="#3-数组实例的includes" class="headerlink" title="3.数组实例的includes()"></a>3.数组实例的includes()</h2><p>该方法返回一个布尔值，表示某个数组是否包含给定的值。没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。</p><p>indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf[<span class="literal">NaN</span>] <span class="comment">//-1</span></span><br><span class="line"></span><br><span class="line">[<span class="literal">NaN</span>].includes(<span class="literal">NaN</span>) <span class="comment">//0</span></span><br></pre></td></tr></table></figure></p><p>注：Map和Set数据结构有一个has方法，注意与includes区分。Map结构的has方法，是来查找键名的<br>Set结构的has方法，是用来查找键值的。</p><h1 id="二-对象升级"><a href="#二-对象升级" class="headerlink" title="二.对象升级"></a>二.对象升级</h1><h2 id="1-Object-assign"><a href="#1-Object-assign" class="headerlink" title="1.Object.assign()"></a>1.Object.assign()</h2><p>用于对象的合并，将原对象的所有<strong>可枚举属性</strong>，复制到目标对象上。</p><p>object.assign拷贝的属性是有限制的，<strong>只拷贝源对象自身的属性</strong>（不拷贝继承属性，也不拷贝不可枚举的属性）<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为对象添加属性和方法</span></span><br><span class="line"><span class="comment">//es6</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, &#123;x, y&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(Point.prototype, &#123;</span><br><span class="line">  addPoint(arg1, arg2) &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这个方法很常用，但一些细节问题还是要拎出来提醒自己注意一下。</p><p><strong>（1）浅拷贝</strong></p><p>Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p><p><strong>（2）同名属性的替换</strong></p><p>对于这种嵌套的对象，一旦遇到同名的属性，Object.assign的处理方法是替换，而不是添加。要特别注意！！</p><p><strong>（3）数组的处理</strong></p><p>Object.assign可以用来处理数组，但是会把数组视为对象。</p><h1 id="2-属性的遍历"><a href="#2-属性的遍历" class="headerlink" title="2.属性的遍历"></a>2.属性的遍历</h1><p>ES6 一共有 5 种方法可以遍历对象的属性。</p><p><strong>（1）for…in</strong></p><p>for…in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p><p><strong>（2）Object.keys(obj)</strong></p><p>Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p><p><strong>（3）Object.getOwnPropertyNames(obj)</strong></p><p>Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）的键名。</p><p><strong>（4）Object.getOwnPropertySymbols(obj)</strong></p><p>Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p><p><strong>（5）Reflect.ownKeys(obj)</strong></p><p>Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p><h1 id="三-函数升级"><a href="#三-函数升级" class="headerlink" title="三. 函数升级"></a>三. 函数升级</h1><h2 id="1-rest参数"><a href="#1-rest参数" class="headerlink" title="1.rest参数"></a>1.rest参数</h2><p>用于获取函数的多余参数，这样就不需要使用arguments对象了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arguments变量的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortNumbers</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>).sort();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rest参数的写法</span></span><br><span class="line"><span class="keyword">const</span> sortNumbers = <span class="function">(<span class="params">...numbers</span>) =&gt;</span> numbers.sort();</span><br></pre></td></tr></table></figure><h2 id="2-箭头函数"><a href="#2-箭头函数" class="headerlink" title="2.箭头函数"></a>2.箭头函数</h2><p>ES6 允许使用“箭头”（=&gt;）定义函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arguments变量的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortNumbers</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>).sort();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rest参数的写法</span></span><br><span class="line"><span class="keyword">const</span> sortNumbers = <span class="function">(<span class="params">...numbers</span>) =&gt;</span> numbers.sort();</span><br></pre></td></tr></table></figure></p><p>注意点：</p><p><strong>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</strong></p><p>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p><p>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p><h1 id="四-for…of循环"><a href="#四-for…of循环" class="headerlink" title="四.for…of循环"></a>四.for…of循环</h1><p>for…of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。</p><h2 id="1-用法"><a href="#1-用法" class="headerlink" title="1.用法"></a>1.用法</h2><p><strong>数组：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为对象添加属性和方法</span></span><br><span class="line"><span class="comment">//es6</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v); <span class="comment">// red green blue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Set 和 Map 结构</strong><br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> engines = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">"Gecko"</span>, <span class="string">"Trident"</span>, <span class="string">"Webkit"</span>, <span class="string">"Webkit"</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> e <span class="keyword">of</span> engines) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Gecko</span></span><br><span class="line"><span class="comment">// Trident</span></span><br><span class="line"><span class="comment">// Webkit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> es6 = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">es6.set(<span class="string">"edition"</span>, <span class="number">6</span>);</span><br><span class="line">es6.set(<span class="string">"committee"</span>, <span class="string">"TC39"</span>);</span><br><span class="line">es6.set(<span class="string">"standard"</span>, <span class="string">"ECMA-262"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [name, value] <span class="keyword">of</span> es6) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name + <span class="string">": "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// edition: 6</span></span><br><span class="line"><span class="comment">// committee: TC39</span></span><br><span class="line"><span class="comment">// standard: ECMA-262</span></span><br></pre></td></tr></table></figure></p><p> <strong>类数组的对象</strong><br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> str) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s); <span class="comment">// h e l l o</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DOM NodeList对象</span></span><br><span class="line"><span class="keyword">let</span> paras = <span class="built_in">document</span>.querySelectorAll(<span class="string">"p"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> paras) &#123;</span><br><span class="line">  p.classList.add(<span class="string">"test"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="built_in">arguments</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">printArgs(<span class="string">'a'</span>, <span class="string">'b'</span>);</span><br><span class="line"><span class="comment">// 'a'</span></span><br><span class="line"><span class="comment">// 'b'</span></span><br></pre></td></tr></table></figure></p><h2 id="2-与其他遍历语法的比较"><a href="#2-与其他遍历语法的比较" class="headerlink" title="2.与其他遍历语法的比较"></a>2.与其他遍历语法的比较</h2><p>for…in循环有几个缺点。</p><ul><li>数组的键名是数字，但是for…in循环是以字符串作为键名“0”、“1”、“2”等等。</li><li>for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，<strong>甚至包括原型链上的键</strong>。</li><li>某些情况下，for…in循环会以任意顺序遍历键名。<br>总之，for…in循环主要是为遍历对象而设计的，不适用于遍历数组。</li></ul><p>forEach循环的缺点是无法中途跳出forEach循环，break命令或return命令都不能奏效。</p><p>与之相对的，for…of有如下优点：</p><ul><li>有着同for…in一样的简洁语法，但是没有for…in那些缺点。</li><li>不同于forEach方法，它可以与break、continue和return配合使用。</li><li>提供了遍历所有数据结构的统一操作接口。</li></ul><h1 id="五-参考网址"><a href="#五-参考网址" class="headerlink" title="五.参考网址"></a>五.参考网址</h1><p> <a href="http://es6.ruanyifeng.com/#docs/iterator#for---of-%E5%BE%AA%E7%8E%AF" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/iterator#for---of-%E5%BE%AA%E7%8E%AF</a></p>]]></content:encoded>
      
      <comments>http://myhexo.whuzxq.com/2018/05/23/es6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【译】为什么需要在 React 类组件中为事件处理程序绑定 this</title>
      <link>http://myhexo.whuzxq.com/2018/05/16/REACT-BIND/</link>
      <guid>http://myhexo.whuzxq.com/2018/05/16/REACT-BIND/</guid>
      <pubDate>Wed, 16 May 2018 11:02:11 GMT</pubDate>
      <description>
      
        &lt;p&gt;在使用 React 时，您难免遇到受控组件和事件处理程序。在自定义组件的构造函数中，我们需要使用 &lt;code&gt;.bind()&lt;/code&gt; 来将方法绑定到组件实例上面。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>在使用 React 时，您难免遇到受控组件和事件处理程序。在自定义组件的构造函数中，我们需要使用 <code>.bind()</code> 来将方法绑定到组件实例上面。<br> <a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Foo extends React.Component&#123;</span><br><span class="line">  constructor( props )&#123;</span><br><span class="line">    super( props );</span><br><span class="line">    this.handleClick = this.handleClick.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick(event)&#123;</span><br><span class="line">    // 你的事件处理逻辑</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button type=&quot;button&quot; </span><br><span class="line">      onClick=&#123;this.handleClick&#125;&gt;</span><br><span class="line">      Click Me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Foo /&gt;,</span><br><span class="line">  document.getElementById(&quot;app&quot;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在这篇文章中，我们将探究为什么要这么做。</p><p>如果你对 <code>.bind()</code> 尚不了解，推荐阅读 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind" target="_blank" rel="noopener">这篇文章</a>。</p><h3 id="应责怪-JavaScript，而不是-React"><a href="#应责怪-JavaScript，而不是-React" class="headerlink" title="应责怪 JavaScript，而不是 React"></a><strong>应责怪 JavaScript，而不是 React</strong></h3><p>好吧，责怪听起来有些苛刻。如果按照 React 和 JSX 的语法，我们并不需要这么做。其实绑定 <code>this</code> 是 JavaScript 中的语法。</p><p>让我们看看，如果不将事件处理程序绑定到组件实例上，会发生什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Foo extends React.Component&#123;</span><br><span class="line">  constructor( props )&#123;</span><br><span class="line">    super( props );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick(event)&#123;</span><br><span class="line">    console.log(this); // &apos;this&apos; 值为 undefined</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button type=&quot;button&quot; onClick=&#123;this.handleClick&#125;&gt;</span><br><span class="line">        Click Me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Foo /&gt;,</span><br><span class="line">  document.getElementById(&quot;app&quot;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果你运行这个代码，点击 “Click Me” 按钮，检查你的控制台，你将会看到控制台打印出  <code>undefined</code>，这个值是 <code>handleClick()</code> 方法内部的 this 值。<code>handleClick()</code> 方法似乎已经<strong>丢失了</strong>其上下文(组件实例)，即 this 值。</p><h3 id="在-JavaScript-中，this-的绑定是如何工作的"><a href="#在-JavaScript-中，this-的绑定是如何工作的" class="headerlink" title="在 JavaScript 中，this 的绑定是如何工作的"></a><strong>在 JavaScript 中，this 的绑定是如何工作的</strong></h3><p>正如我上文提到的，是 JavaScript 的 <code>this</code> 绑定机制导致了上述情况的发生。在这篇文章中，我不会深入探讨太多细节，但是 <a href="https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch2.md" target="_blank" rel="noopener">这篇文章</a> 可以帮助你进一步学习在 JavaScript 中 this 的绑定是如何工作的。</p><p>与我们讨论相关的是，函数内部的 <code>this</code> 的值取决于该函数如何被调用。</p><h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a><strong>默认绑定</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function display()&#123;</span><br><span class="line"> console.log(this); // &apos;this&apos; 将指向全局变量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">display();</span><br></pre></td></tr></table></figure><p>这是一个普通的函数调用。在这种情况下，<code>display()</code> 方法中的 <code>this</code> 在非严格模式下指向 window 或 global 对象。在严格模式下，<code>this</code> 指向 <code>undefined</code>。</p><h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a><strong>隐式绑定</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line"> name: &apos;Saurabh&apos;,</span><br><span class="line"> display: function()&#123;</span><br><span class="line">   console.log(this.name); // &apos;this&apos; 指向 obj</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.display(); // Saurabh</span><br></pre></td></tr></table></figure><p>当我们以一个 obj 对象来调用这个函数时，<code>display()</code> 方法内部的 <code>this</code> 指向 <code>obj</code>。</p><p>但是，当我们将这个函数引用赋值给某个其他变量并使用这个新的函数引用去调用该函数时，我们在 <code>display()</code> 中获得了不同的<code>this</code>值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;uh oh! global&quot;;</span><br><span class="line">var outerDisplay = obj.display;</span><br><span class="line">outerDisplay(); // uh oh! global</span><br></pre></td></tr></table></figure><p>在上面的例子里，当我们调用 <code>outerDisplay()</code> 时，我们没有指定一个具体的上下文对象。这是一个没有所有者对象的纯函数调用。在这种情况下，<code>display()</code> 内部的 <code>this</code> 值回退到<strong>默认绑定</strong>。现在这个 <code>this</code> 指向全局对象，在严格模式下，它指向 <code>undefined</code>。</p><p>在将这些函数以回调的形式传递给另一个自定义函数、第三方库函数或者像 <code>setTimeout</code> 这样的内置JavaScript函数时，上面提到的判断方法会特别实用。</p><p>考虑下方的代码，当自定义一个 <code>setTimeout</code> 方法并调用它，会发生什么。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//setTimeout 的虚拟实现</span><br><span class="line">function setTimeout(callback, delay)&#123;</span><br><span class="line"></span><br><span class="line">   //等待 &apos;delay&apos; 数个毫秒</span><br><span class="line"></span><br><span class="line">   callback();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout( obj.display, 1000 );</span><br></pre></td></tr></table></figure><p>我们可以分析出，当调用 <code>setTimeout</code> 时，JavaScript 在内部将 <code>obj.display</code> 赋给参数 <code>callback</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback = obj.display;</span><br></pre></td></tr></table></figure><p>正如我们之前分析的，这种赋值操作会导致 <code>display()</code> 函数丢失其上下文。当此函数最终在 <code>setTimeout</code> 函数里面被调用时，<code>display()</code>内部的 <code>this</code> 的值会退回至<strong>默认绑定</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;uh oh! global&quot;;</span><br><span class="line">setTimeout( obj.display, 1000 );</span><br><span class="line"></span><br><span class="line">// uh oh! global</span><br></pre></td></tr></table></figure><h4 id="明确绑定"><a href="#明确绑定" class="headerlink" title="明确绑定"></a><strong>明确绑定</strong></h4><p>为了避免这种情况，我们可以使用 <strong>明确绑定方法</strong>，将 <code>this</code> 的值通过 <code>bind()</code> 方法绑定到函数上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;uh oh! global&quot;;</span><br><span class="line">obj.display = obj.display.bind(obj); </span><br><span class="line">var outerDisplay = obj.display;</span><br><span class="line">outerDisplay();</span><br><span class="line"></span><br><span class="line">// Saurabh</span><br></pre></td></tr></table></figure><p>现在，当我们调用 <code>outerDisplay()</code> 时，<code>this</code> 的值指向 <code>display()</code> 内部的 <code>obj</code>。</p><p>即时我们将 <code>obj.display</code> 直接作为 callback 参数传递给函数，<code>display()</code> 内部的 <code>this</code> 也会正确地指向 <code>obj</code>。</p><h3 id="仅使用-JavaScript-重新创建场景"><a href="#仅使用-JavaScript-重新创建场景" class="headerlink" title="仅使用 JavaScript 重新创建场景"></a><strong>仅使用 JavaScript 重新创建场景</strong></h3><p>在本文的开头，我们创建了一个类名为 <code>Foo</code> 的 React 组件。如果我们不将 <code>this</code> 绑定到事件上，事件内的值会变成 <code>undefined</code>。</p><p>正如我上文解释的那样，这是由 JavaScript 中 <code>this</code> 绑定的方式决定的，与React的工作方式无关。因此，让我们删除 React 本身的代码，并构建一个类似的纯 JavaScript 示例，来模拟此行为。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  constructor(name)&#123;</span><br><span class="line">    this.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  display()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo = new Foo(&apos;Saurabh&apos;);</span><br><span class="line">foo.display(); // Saurabh</span><br><span class="line"></span><br><span class="line">//下面的赋值操作模拟了上下文的丢失。 </span><br><span class="line">//与实际在 React Component 中将处理程序作为 callback 参数传递相似。</span><br><span class="line">var display = foo.display; </span><br><span class="line">display(); // TypeError: this is undefined</span><br></pre></td></tr></table></figure><p>我们不是模拟实际的事件和处理程序，而是用同义代码替代。正如我们在 React 组件示例中所看到的那样，由于将处理程序作为回调传递后，丢失了上下文，导致 <code>this</code> 值变成 <code>undefined</code>。这也是我们在这个纯 JavaScript 代码片段中观察到的。 </p><p>你可能会问：“等一下！难道 <code>this</code> 的值不是应该指向全局对象么，因为我们是按照默认绑定的规则，在非严格模式下运行的它。“</p><p><strong>答案是否定的</strong> 原因如下：</p><blockquote><p><em>类声明</em>和<em>类表达式</em>的主体以 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener">严格模式</a> 执行，主要包括构造函数、静态方法和原型方法。Getter 和 setter 函数也在严格模式下执行。</p></blockquote><p>你可以在 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">这里</a> 阅读完整的文章。</p><p>所以为了避免错误，我们需要像下文这样绑定 <code>this</code> 的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  constructor(name)&#123;</span><br><span class="line">    this.name = name</span><br><span class="line">    this.display = this.display.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  display()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo = new Foo(&apos;Saurabh&apos;);</span><br><span class="line">foo.display(); // Saurabh</span><br><span class="line"></span><br><span class="line">var display = foo.display;</span><br><span class="line">display(); // Saurabh</span><br></pre></td></tr></table></figure><p>我们不仅可以在构造函数中执行此操作，也可以在其他位置执行此操作。考虑这个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  constructor(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  display()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo = new Foo(&apos;Saurabh&apos;);</span><br><span class="line">foo.display = foo.display.bind(foo);</span><br><span class="line">foo.display(); // Saurabh</span><br><span class="line"></span><br><span class="line">var display = foo.display;</span><br><span class="line">display(); // Saurabh</span><br></pre></td></tr></table></figure><p>但由于构造函数是所有初始化发生的地方，因此它是编写绑定事件语句最佳的位置。</p><h4 id="为什么我们不需要为箭头函数绑定-‘this’？"><a href="#为什么我们不需要为箭头函数绑定-‘this’？" class="headerlink" title="为什么我们不需要为箭头函数绑定 ‘this’？"></a><strong>为什么我们不需要为箭头函数绑定 <code>‘this’</code>？</strong></h4><p>在 React 组件内，我们有另外两种定义事件处理程序的方式。</p><ul><li><a href="https://babeljs.io/docs/plugins/transform-class-properties/" target="_blank" rel="noopener"><strong>公共类字段语法(实验)</strong></a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Foo extends React.Component&#123;</span><br><span class="line">  handleClick = () =&gt; &#123;</span><br><span class="line">    console.log(this); </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  render()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button type=&quot;button&quot; onClick=&#123;this.handleClick&#125;&gt;</span><br><span class="line">        Click Me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Foo /&gt;,</span><br><span class="line">  document.getElementById(&quot;app&quot;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener"><strong>回调中的箭头函数</strong></a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Foo extends React.Component&#123;</span><br><span class="line"> handleClick(event)&#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  render()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button type=&quot;button&quot; onClick=&#123;(e) =&gt; this.handleClick(e)&#125;&gt;</span><br><span class="line">        Click Me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Foo /&gt;,</span><br><span class="line">  document.getElementById(&quot;app&quot;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这两个都使用了ES6引入的箭头函数。当使用这些替代方法时，我们的事件处理程序已经自动绑定到了组件实例上，并且我们不需要在构造函数中绑定它。</p><p>原因是在箭头函数的情况下，<code>this</code> 是有<strong>词法</strong>约束力的。这意味它可以使用封闭的函数上下文或者全局上下文作为 <code>this</code> 的值。</p><p>在公共类字段语法的例子中，箭头函数被包含在 <code>Foo</code> 类中或者构造函数中，所以它的上下文就是组件实例，而这就是我们想要的。</p><p>在箭头函数作为回调的例子中，箭头函数被包含在 <code>render()</code> 方法中，该方法由 React 在组件实例的上下文中调用。这就是为什么箭头函数也可以捕获相同的上下文，并且其中的 <code>this</code> 值将正确的指向组件实例。</p><p>有关 <code>this</code> 绑定的更多细节，请查看 <a href="https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch2.md#lexical-this" target="_blank" rel="noopener">此优秀资源</a>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>在 React 的类组件中，当我们把事件处理函数引用作为回调传递过去，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button type=&quot;button&quot; onClick=&#123;this.handleClick&#125;&gt;Click Me&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>事件处理程序方法会丢失其<strong>隐式绑定</strong>的上下文。当事件被触发并且处理程序被调用时，<code>this</code>的值会回退到<strong>默认绑定</strong>，即值为 <code>undefined</code>，这是因为类声明和原型方法是以严格模式运行。</p><p>当我们将事件处理程序的 <code>this</code> 绑定到构造函数中的组件实例时，我们可以将它作为回调传递，而不用担心会丢失它的上下文。</p><p>箭头函数可以免除这种行为，因为它使用的是<strong>词法</strong> <code>this</code> <strong>绑定</strong>，会将其自动绑定到定义他们的函数上下文。</p><hr><blockquote><p><a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im" target="_blank" rel="noopener">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android" target="_blank" rel="noopener">Android</a>、<a href="https://github.com/xitu/gold-miner#ios" target="_blank" rel="noopener">iOS</a>、<a href="https://github.com/xitu/gold-miner#前端" target="_blank" rel="noopener">前端</a>、<a href="https://github.com/xitu/gold-miner#后端" target="_blank" rel="noopener">后端</a>、<a href="https://github.com/xitu/gold-miner#区块链" target="_blank" rel="noopener">区块链</a>、<a href="https://github.com/xitu/gold-miner#产品" target="_blank" rel="noopener">产品</a>、<a href="https://github.com/xitu/gold-miner#设计" target="_blank" rel="noopener">设计</a>、<a href="https://github.com/xitu/gold-miner#人工智能" target="_blank" rel="noopener">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi" target="_blank" rel="noopener">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi" target="_blank" rel="noopener">知乎专栏</a>。</p></blockquote>]]></content:encoded>
      
      <comments>http://myhexo.whuzxq.com/2018/05/16/REACT-BIND/#disqus_thread</comments>
    </item>
    
    <item>
      <title>你真的完全掌握了promise么？</title>
      <link>http://myhexo.whuzxq.com/2018/05/10/promise/</link>
      <guid>http://myhexo.whuzxq.com/2018/05/10/promise/</guid>
      <pubDate>Thu, 10 May 2018 15:26:08 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近在整理js中异步编程方法时，回顾了一下promise，又发现了一些遗漏的重要知识点，比如promise.resolve()传递不同参数的含义？比如当一个promise依赖另一个promise时事件执行顺序？比如当catch捕获到了错误后，会不会继续执行后面的then方法？下文将对这些问题一一解答，并再次强调一些重要的知识点。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>最近在整理js中异步编程方法时，回顾了一下promise，又发现了一些遗漏的重要知识点，比如promise.resolve()传递不同参数的含义？比如当一个promise依赖另一个promise时事件执行顺序？比如当catch捕获到了错误后，会不会继续执行后面的then方法？下文将对这些问题一一解答，并再次强调一些重要的知识点。<br><a id="more"></a></p><h1 id="1-promise语法"><a href="#1-promise语法" class="headerlink" title="1.promise语法"></a>1.promise语法</h1><p>   Promise编程的核心思想是<strong>如果数据就绪(promised)，那么(then)做点什么。</strong></p><p> 下文是一个promise实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。</p><p> <strong>resolve函数的作用是</strong>，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</p><p> <strong>reject函数的作用是</strong>，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为rejected）， 在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 </p><p> Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>then方法可以接受两个回调函数作为参数。</strong></p><p>第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</p><p>下面是一个使用then的例子。<strong>then方法返回的是一个新的Promise实例。</strong> 因此可以采用链式写法，即then方法后面再调用另一个then方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> json.post;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p><p><strong>Promise.prototype.catch方法</strong>用于指定发生错误时的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">'/posts.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">posts</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'发生错误！'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，getJSON方法返回一个 Promise 对象；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，<strong>then方法</strong>指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。</p><p>一般总是建议，Promise 对象后面要跟catch方法，这样可以处理 Promise 内部发生的错误。<strong>catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。</strong></p><p><strong>注意：</strong> </p><p>1.如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  resolve(p1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码中，p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。</p><p>这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。</p><p>2.调用resolve或reject并不会终结 Promise 的参数函数的执行。</p><p>3.then方法是定义在原型对象Promise.prototype上的。</p><p>4.如果没有使用catch方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。</p><p>5.Promise 在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise的状态一旦改变，就永久保持该状态，不会再变了。</p><h1 id="2-Promise-resolve"><a href="#2-Promise-resolve" class="headerlink" title="2. Promise.resolve()"></a>2. Promise.resolve()</h1><p>有时需要将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用。</p><p>Promise.resolve等价于下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">'foo'</span>))</span><br></pre></td></tr></table></figure><p>Promise.resolve方法的参数分成四种情况。</p><p><strong>1）参数是一个 Promise 实例</strong></p><p>如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。</p><p><strong>2）参数是一个thenable对象</strong></p><p>thenable对象指的是具有then方法的对象，比如下面这个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Promise.resolve方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);  <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出 42。</p><p><strong>3）参数不是具有then方法的对象，或根本就不是对象。</strong></p><p>如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个<strong>新的 Promise 对象</strong>，状态为resolved。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">'Hello'</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><p>上面代码生成一个新的 Promise 对象的实例p。由于字符串Hello不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是resolved，所以回调函数会立即执行。Promise.resolve方法的参数，会同时传给回调函数。</p><p><strong>4）不带有任何参数</strong></p><p>Promise.resolve方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。</p><p>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用Promise.resolve方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码的变量p就是一个 Promise 对象。需要注意的是，<strong>立即resolve的 Promise 对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'three'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'two'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'one'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// three</span></span><br></pre></td></tr></table></figure><p>上面代码中，setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise. resolve()在本轮“事件循环”结束时执行，console.log(‘one’)则是立即执行，因此最先输出。</p><h1 id="3-新手错误"><a href="#3-新手错误" class="headerlink" title="3.新手错误"></a>3.新手错误</h1><p><strong>1）用了 promises 后怎么用 forEach?</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我想删除所有的docs</span></span><br><span class="line">db.allDocs(&#123;<span class="attr">include_docs</span>: <span class="literal">true</span>&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  result.rows.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">row</span>) </span>&#123;</span><br><span class="line">    db.remove(row.doc);  </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 我天真的以为所有的docs都被删除了！</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>问题在于第一个函数实际上返回的是 undefined，这意味着第二个方法不会等待所有 documents 都执行 db.remove()。实际上他不会等待任何事情，并且可能会在任意数量的文档被删除后执行！</p><p>简而言之，forEach()/for/while 并非你寻找的解决方案。你需要的是 Promise.all():</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.allDocs(&#123;<span class="attr">include_docs</span>: <span class="literal">true</span>&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all(result.rows.map(<span class="function"><span class="keyword">function</span> (<span class="params">row</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> db.remove(row.doc);</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">arrayOfResults</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// All docs have really been removed() now!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码是什么意思呢？大体来说，Promise.all()会以一个 promises 数组为输入，并且返回一个新的 promise。这个新的 promise 会在数组中所有的 promises 都成功返回后才返回。他是异步版的 for 循环。</p><p>并且 Promise.all() 会将执行结果组成的数组返回到下一个函数，比如当你希望从 PouchDB 中获取多个对象时，会非常有用。此外一个更加有用的特效是，一旦数组中的 promise 任意一个返回错误，Promise.all() 也会返回错误。</p><p><strong>2）忘记使用catch</strong></p><p>单纯的坚信自己的 promises 会永远不出现异常，很多开发者会忘记在他们的代码中添加一个 .catch()。然而不幸的是这也意味着，任何被抛出的异常都会被吃掉，并且你无法在 console 中观察到他们。这类问题 debug 起来会非常痛苦。</p><p><strong>3) 使用副作用调用而非返回</strong></p><p>下面的代码有什么问题？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  someOtherPromise();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 我希望someOtherPromise() 状态变成resolved!</span></span><br><span class="line">  <span class="comment">// 但是并没有</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>每一个 promise 都会提供给你一个 then() 函数 (或是 catch()，实际上只是 then(null, …) 的语法糖)。当我们在 then() 函数内部时：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// I'm inside a then() function!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们可以做什么呢？有三种事情：</p><ul><li>return 另一个 promise</li><li>return 一个同步的值 (或者 undefined)</li><li>throw 一个同步异常</li></ul><p>就是这样。一旦你理解了这个技巧，你就理解了 promises。</p><p>因此让我们逐个了解下。</p><p><strong>返回另一个 promise</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getUserAccountById(user.id);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// I got a user account!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：我是 <code>return</code> 第二个 promise，这个 <code>return</code> 非常重要。如果我没有写 <code>return</code>，<code>getUserAccountById()</code> 就会成为一个副作用，并且下一个函数将会接收到 <code>undefined</code> 而非 <code>userAccount</code>。</p><p><strong>返回一个同步值 (或者 undefined)</strong></p><p>返回 undefined 通常是错误的，但是返回一个同步值实际上是将同步代码包裹为 promise 风格代码的一种非常赞的手段。举例来说，我们对 users 信息有一个内存缓存。我们可以这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (inMemoryCache[user.id]) &#123;</span><br><span class="line">    <span class="keyword">return</span> inMemoryCache[user.id];    <span class="comment">// returning a synchronous value!</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getUserAccountById(user.id); <span class="comment">// returning a promise!</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// I got a user account!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>第二个函数不需要关心 userAccount 是从同步方法还是异步方法中获取的，并且第一个函数可以非常自由的返回一个同步或者异步值。</p><p><strong>抛出同步异常</strong></p><p>比如我们希望在用户已经登出时，抛出一个同步异常。这会非常简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (user.isLoggedOut()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'user logged out!'</span>); <span class="comment">// throwing a synchronous error!</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (inMemoryCache[user.id]) &#123;</span><br><span class="line">    <span class="keyword">return</span> inMemoryCache[user.id];       <span class="comment">// returning a synchronous value!</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getUserAccountById(user.id);    <span class="comment">// returning a promise!</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// I got a user account!</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Boo, I got an error!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果用户已经登出，我们的 catch() 会接收到一个同步异常，并且如果 后续的 promise 中出现异步异常，他也会接收到。再强调一次，这个函数并不需要关心这个异常是同步还是异步返回的。</p><h1 id="4-参考网址"><a href="#4-参考网址" class="headerlink" title="4.参考网址"></a>4.参考网址</h1><p><a href="http://fex.baidu.com/blog/2015/07/we-have-a-problem-with-promises/" target="_blank" rel="noopener">http://fex.baidu.com/blog/2015/07/we-have-a-problem-with-promises/</a></p><p><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/promise</a></p>]]></content:encoded>
      
      <comments>http://myhexo.whuzxq.com/2018/05/10/promise/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JS异步编程——深入理解async/await</title>
      <link>http://myhexo.whuzxq.com/2018/05/06/async/</link>
      <guid>http://myhexo.whuzxq.com/2018/05/06/async/</guid>
      <pubDate>Sun, 06 May 2018 12:26:11 GMT</pubDate>
      <description>
      
        &lt;p&gt;在做项目的时候，经常会碰到关于异步的问题，遇到多个异步请求，又要控制其顺序，该怎么办？涉及多个回调形成回调地狱又该如何处理？ES2017 标准引入了 async 函数，使得异步操作变得更加方便。本文主要从async/await的基本用法、平行任务、注意事项几个方面来介绍。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>在做项目的时候，经常会碰到关于异步的问题，遇到多个异步请求，又要控制其顺序，该怎么办？涉及多个回调形成回调地狱又该如何处理？ES2017 标准引入了 async 函数，使得异步操作变得更加方便。本文主要从async/await的基本用法、平行任务、注意事项几个方面来介绍。<br><a id="more"></a></p><h1 id="0-传统js的异步编程方法"><a href="#0-传统js的异步编程方法" class="headerlink" title="0.传统js的异步编程方法"></a>0.传统js的异步编程方法</h1><p>ES6 诞生以前，异步编程的方法，大概有下面四种。</p><ul><li>回调函数</li><li>事件监听</li><li>发布/订阅</li><li>promise对象</li></ul><h1 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1.基本用法"></a>1.基本用法</h1><p>首先我们通过一个例子，分别使用async/await与传统异步方法进行编写，进而对async/await写法有个初步的了解。</p><p>先定义一个 Fetch 方法用于获取信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchUser</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        fetch(<span class="string">'https://whuzxq.com/userList/4356'</span>)</span><br><span class="line">        .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">            resolve(data.json());</span><br><span class="line">        &#125;, (error) =&gt; &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Promise方式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getuserByPromise</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    fetchUser()</span><br><span class="line">        .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(data);</span><br><span class="line">        &#125;, (error) =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(error);</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Promise的方式虽然解决了回调地狱，但是整段代码充满then，语义化不明显，代码流程不能很好的表示执行流程。</p><p><strong>async 方式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * async 方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getUserByAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">let</span> user = <span class="keyword">await</span> fetchUser();</span><br><span class="line">     <span class="keyword">return</span> user;</span><br><span class="line"> &#125;</span><br><span class="line">getUserByAsync()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v));</span><br></pre></td></tr></table></figure><p>async 函数完美的解决了上面两种方式的问题。同时 async 函数自带执行器，执行的时候无需手动加载。</p><p>通过以上两个例子，应该对async的使用有了一个初步的认识，下文将详细列出async/await相关的重要知识点。</p><h1 id="async"><a href="#async" class="headerlink" title="async"></a>async</h1><p>1.async函数返回一个promise对象。<br>2.async函数内部return语句返回的值，会成为then方法回调函数的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hello world'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br></pre></td></tr></table></figure><p>3.async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getTitle</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">  <span class="keyword">let</span> html = <span class="keyword">await</span> response.text();</span><br><span class="line">  <span class="keyword">return</span> html.match(<span class="regexp">/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i</span>)[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">getTitle(<span class="string">'https://tc39.github.io/ecma262/'</span>).then(<span class="built_in">console</span>.log)</span><br><span class="line"><span class="comment">// "ECMAScript 2017 Language Specification"</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数getTitle内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行then方法里面的console.log。</p><h1 id="await命令"><a href="#await命令" class="headerlink" title="await命令"></a>await命令</h1><p>需要理解以下要点：<br>1.正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>2.只要一个await语句后面的 Promise 变为reject，那么整个async函数都会中断执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个await放在try…catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>)</span><br><span class="line">    .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// 出错了</span></span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>1.前面已经说过，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中。<br>2.await命令只能用在async函数之中，如果用在普通函数，就会报错。</p><h1 id="2-等待平行任务"><a href="#2-等待平行任务" class="headerlink" title="2.等待平行任务"></a>2.等待平行任务</h1><p>进行 JavaScript 异步编程时，大家经常需要逐一编写多个复杂语句的代码，并都在调用语句前标注了 <strong>await</strong>。由于大多数情况下，一个语句并不依赖于前一个语句，但是你仍不得不等前一个语句完成，这会导致性能问题。因此，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> getFoo();</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> getBar();</span><br></pre></td></tr></table></figure><p>上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = getFoo();</span><br><span class="line"><span class="keyword">let</span> barPromise = getBar();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br></pre></td></tr></table></figure><h1 id="3-实例"><a href="#3-实例" class="headerlink" title="3.实例"></a>3.实例</h1><p>实例一：假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">chainAnimationsAsync</span>(<span class="params">elem, animations</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ret = <span class="literal">null</span>;<span class="comment">//变量ret用来保存上一个动画的返回值</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> anim <span class="keyword">of</span> animations) &#123;</span><br><span class="line">      ret = <span class="keyword">await</span> anim(elem);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="comment">/* 忽略错误，继续执行 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例二：实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">logInOrder</span>(<span class="params">urls</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> url <span class="keyword">of</span> urls) &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> response.text());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">logInOrder</span>(<span class="params">urls</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 并发读取远程URL</span></span><br><span class="line">  <span class="keyword">const</span> textPromises = urls.map(<span class="keyword">async</span> url =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">    <span class="keyword">return</span> response.text();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按次序输出</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> textPromise <span class="keyword">of</span> textPromises) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> textPromise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。后面的for..of循环内部使用了await，因此实现了按顺序输出。</p><h1 id="4-参考网址"><a href="#4-参考网址" class="headerlink" title="4.参考网址"></a>4.参考网址</h1><p><a href="http://es6.ruanyifeng.com/#docs/async" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/async</a><br><a href="https://github.com/xitu/gold-miner/pull/3738/files" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/pull/3738/files</a><br><a href="https://juejin.im/post/596e142d5188254b532ce2da" target="_blank" rel="noopener">https://juejin.im/post/596e142d5188254b532ce2da</a><br><a href="https://juejin.im/post/5ade84c951882567113ad246" target="_blank" rel="noopener">https://juejin.im/post/5ade84c951882567113ad246</a></p>]]></content:encoded>
      
      <comments>http://myhexo.whuzxq.com/2018/05/06/async/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
